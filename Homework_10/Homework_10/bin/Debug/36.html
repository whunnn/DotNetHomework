<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin-when-crossorigin" />
    <meta name="description" content="字典 Python中的字典（dict）也被称为映射（mapping）或者散列（hash），是支持Python底层实现的重要数据结构。 同时，也是应用最为广泛的数据结构，内部采用hash存储，存储方式为" />
    <meta property="og:description" content="字典 Python中的字典（dict）也被称为映射（mapping）或者散列（hash），是支持Python底层实现的重要数据结构。 同时，也是应用最为广泛的数据结构，内部采用hash存储，存储方式为" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>老Python总结的字典相关知识 - 云崖先生 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=zS6-e1bxywlu3kpHvpr1J6MySwya3ztFtEnS7RYQ0Fk" />
    
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/Yunya-Cnblogs/custom.css?v=RQZmXpp4yXZkm/yVJRG6kfh6iLs=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/custom/bundle-custom-mobile.min.css?v=OayYBbtUbH4FYkn_bTL4VVf4DsEOiTHSWhbl11KyY6Y" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/Yunya-Cnblogs/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/Yunya-Cnblogs/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/Yunya-Cnblogs/wlwmanifest.xml" />
    <script>
        var currentBlogId = 569467;
        var currentBlogApp = 'Yunya-Cnblogs';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'Custom';
        var visitorUserId = '';
    </script>
        <script>
            var currentPostDateAdded = '2021-05-03 04:29';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=yJQaJ16S00coMfzvh-NgF2zm2J87f5VfNamFdsnKHrc"></script>
    
    
    
</head>
<body class="no-navbar">
    <a name="top"></a>
        <div id="bannerbar" class="bannerbar-mobile formobile">
            <a href="https://www.aliyun.com/minisite/goods?userCode=swh7dvlt" target="_blank" onclick="ga('send', 'event', 'Link', 'click', 'aliyun-cps-blog-bannerbar-mobile')">
                <img src="https://img2020.cnblogs.com/blog/35695/202104/35695-20210428213541700-642740375.jpg" alt="" />
            </a>
        </div>
    <div id="top_nav" class="navbar forpc navbar-custom">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding"><a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo" /></a></li>
                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>
                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3" />
                        <button type="submit" id="zzk_search_button">
                            <img src="/images/aggsite/search.svg" alt="搜索" />
                        </button>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                        <img id="new_post_icon" class="navbar-icon" src="/images/aggsite/newpost.svg" alt="写随笔" />
                    </a>
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=J0WS2P2iPgaIVgXxcAhliw4AFZIpaTWxtdoNAv9eiCA" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <img id="navbar_lite_mode_on" src="/images/lite-mode-check.svg" class="hide" /><span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>
                            <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    <div id="page_begin_html">
        <!-- 进度条 -->
<div id="top-progress-bar"
    style="position: fixed; top: 0px; left: 0px; right: 0px; background-color: rgb(244, 67, 54); height: 2px; width: 0%; transition: width 0.2s ease 0s, opacity 0.6s ease 0s;">
</div>
<!-- 右上角github-->
<a href="https://github.com/Yunya-Github/" rel="noopener external nofollow noreferrer" target="_blank"
    class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
            d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
            fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path>
        <path
            d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
            fill="currentColor" class="octo-body"></path>
    </svg></a>
<header class="header">
    <div class="header-inner">
        <!-- 头部banner-->
        <div class="site-brand-container">
            <div class="site-nav-toggle">
                <div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span
                        class="toggle-line toggle-line-middle"></span> <span
                        class="toggle-line toggle-line-last"></span></div>
            </div>
            <div class="site-meta"><a href="https://www.cnblogs.com/YunyaSir/" class="brand" rel="start"><span
                        class="logo-line-before"><i></i></span>
                    <h1 class="site-title">摘星小筑</h1><span class="logo-line-after"><i></i></span>
                </a></div>
            <div class="site-nav-right">
                <div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div>
            </div>
        </div>
        <!-- 导航-->
        <nav class="site-nav">
            <ul id="menu" class="menu">
                <li class="menu-item menu-item-home menu-item-active"><a class="menu-item-inner"
                        href="https://www.cnblogs.com/YunyaSir/" rel="section"><i
                            class="fa fa-fw fa-file-text"></i>首页</a>
                </li>
                <li class="menu-item"><a class="menu-item-inner" href="https://i.cnblogs.com/" rel="section"><i
                            class="fa fa-fw fa-cog"></i>后台</a></li>
                <li class="menu-item"><a class="menu-item-inner" href="https://www.cnblogs.com/" rel="section"><i
                            class="fa fa-fw fa-globe"></i>博客园</a></li>
                <li class="menu-item menu-item-search"><a class="menu-item-inner search-wrap"><i
                            class="fa fa-search fa-fw"></i><input type="text" id="q"
                            onkeydown="return zzk_go_enter(event);" class="input_my_zzk" placeholder="按下Enter搜索"></a>
                </li>
            </ul>
        </nav>
    </div>
</header>
    </div>
    <!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/Yunya-Cnblogs/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/Yunya-Cnblogs/">摘星小筑</a>
</h1>
<h2></h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li>
</li>
<li>

</li>
<li>


</li>
<li>
</li>
<li>

<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			<div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/Yunya-Cnblogs/p/14727708.html">
    <span>老Python总结的字典相关知识</span>
    



</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
<h1 id="字典">字典</h1>
<p>Python中的字典（dict）也被称为映射（mapping）或者散列（hash），是支持Python底层实现的重要数据结构。</p>
<p>同时，也是应用最为广泛的数据结构，内部采用hash存储，存储方式为键值对，需要注意的是键（key）必须为不可变类型，而值（value）可以是任意类型。</p>
<p>字典本身属于可变容器类型，其中一组键值对被视为容器中的一组数据项。</p>
<p>字典的优点是单点查找速度极快，而不能够支持范围查找，此外也比较占用内存。</p>
<h2 id="基本声明">基本声明</h2>
<p>以下是使用类的形式进行声明：</p>
<pre><code>userInfo = dict(name="YunYa", age=18, hobby=["football, music"])
print("值:%r,类型：%r" % (userInfo, type(userInfo)))

# 值:{'name': 'YunYa', 'age': 18, 'hobby': ['football, music']},类型：&lt;class 'dict'&gt;
</code></pre>
<p>也可以选择使用更方便的字面量形式，使用{}对键值对进行包裹，键值对采用k:v的形式分割，多个键值对之间使用,进行分割：</p>
<pre><code>userInfo = {"name": "YunYa", "age": 18, "hobby": ["football, music"]}
print("值:%r,类型：%r" % (userInfo, type(userInfo)))

# 值:{'name': 'YunYa', 'age': 18, 'hobby': ['football, music']},类型：&lt;class 'dict'&gt;
</code></pre>
<p>声明dict时，千万注意key只能是不可变类型。</p>
<p>如str，int，float，bool，tuple等等，使用可变类型作为key会抛出异常。</p>
<h2 id="声明速度">声明速度</h2>
<p>字面量形式和实例类的形式声明究竟哪个更快？</p>
<p>实际上字面量形式比实例类的速度大约快3倍。</p>
<p>我们可以使用一个<a href="https://docs.python.org/zh-cn/3/library/timeit.html" target="_blank">timeit</a>模块，来测出两者的时间差：</p>
<pre><code>$ python -m timeit -n 1000000 -r 5 -v "dict()"
raw times: 0.0865 0.0849 0.0845 0.0962 0.0842
1000000 loops, best of 5: 0.0842 usec per loop

$  python -m timeit -n 1000000 -r 5 -v "{}"
raw times: 0.0273 0.027 0.0278 0.0284 0.0265
1000000 loops, best of 5: 0.0265 usec per loop
</code></pre>
<p>① -n 语句执行多少次</p>
<p>② -r 重复计时器的次数，默认为5</p>
<p>为什么会出现这样的情况，可以使用<a href="https://docs.python.org/zh-cn/3.6/library/dis.html" target="_blank">dis</a>模块来探索，该模块会通过反汇编来查看到语句执行情况的字节码。</p>
<pre><code>$ echo "{}" &gt; demo.py
$ python -m dis demo.py
  1           0 BUILD_MAP                0
              3 POP_TOP
              4 LOAD_CONST               0 (None)
              7 RETURN_VALUE
              
$ echo "dict()" &gt; demo.py
$ python -m dis demo.py
  1           0 LOAD_NAME                0 (dict)
              3 CALL_FUNCTION            0
              6 POP_TOP
              7 LOAD_CONST               0 (None)
             10 RETURN_VALUE
</code></pre>
<p>可以查看到，使用dict()形式进行声明时，必定会调用函数、调用函数的过程会发起系统调用栈的进出栈操作，故更加耗时。</p>
<p>不仅仅是字典的声明、包括所有内置数据结构的声明都推荐使用字面量形式。</p>
<p>如下所示，列表也有相同的情况发生，其他内置的数据结构不再进行演示：</p>
<pre><code>$ echo "[]" &gt; demo.py
$ python -m dis demo.py
  1           0 BUILD_LIST               0
              3 POP_TOP
              4 LOAD_CONST               0 (None)
              7 RETURN_VALUE
              
$ echo "list()" &gt; demo.py
$ python -m dis demo.py
  1           0 LOAD_NAME                0 (list)
              3 CALL_FUNCTION            0
              6 POP_TOP
              7 LOAD_CONST               0 (None)
             10 RETURN_VALUE
</code></pre>
<h2 id="续行操作">续行操作</h2>
<p>在Python中，字典中的数据项如果过多，可能会导致整个字典太长。</p>
<p>Python虽然提供了续行符\，但是在字典中可以忽略续行符，如下所示：</p>
<pre><code>userInfo = {
    "name": "YunYa",
    "age": 18,
    "hobby": ["football, music"]}
print("值:%r,类型：%r" % (userInfo, type(userInfo)))

# 值:{'name': 'YunYa', 'age': 18, 'hobby': ['football, music']},类型：&lt;class 'dict'&gt;
</code></pre>
<h2 id="多维嵌套">多维嵌套</h2>
<p>字典中可以进行多维嵌套，如字典套字典，字典套元组，字典套列表等：</p>
<pre><code>dic = {
    "k1": [1, 2, 3],
    "k2": (1, 2, 3),
    "k3": {
        "k3-1": 1,
        "k3-2": 2,
    },
}
</code></pre>
<h2 id="类型转换">类型转换</h2>
<p>字典可以与布尔类型和字符串进行转换，这是最常用的。</p>
<pre><code>dic = {"k1": "v1", "k2": "v2"}
boolDict = bool(dic)  # 布尔类型
strDict = str(dic)    # 字符串类型

print("值:%r,类型：%r" % (boolDict, type(boolDict)))
print("值:%r,类型：%r" % (strDict, type(strDict)))

# 值:True,类型：&lt;class 'bool'&gt;
# 值:"{'k1': 'v1', 'k2': 'v2'}",类型：&lt;class 'str'&gt;
</code></pre>
<p>如果要将字典转换为列表、元组、集合类型，直接转换只会拿到键，并不会拿到值。</p>
<p>尤其注意这一点，但是其实这样用的场景十分少见，记住就行了：</p>
<pre><code>dic = {"k1": "v1", "k2": "v2"}
listDict = list(dic)    # 列表类型
tupleDict = tuple(dic)  # 元组类型
setDict = set(dic)      # 集合类型

print("值:%r,类型：%r" % (listDict, type(listDict)))
print("值:%r,类型：%r" % (tupleDict, type(tupleDict)))
print("值:%r,类型：%r" % (setDict, type(setDict)))

# 值:['k1', 'k2'],类型：&lt;class 'list'&gt;
# 值:('k1', 'k2'),类型：&lt;class 'tuple'&gt;
# 值:{'k2', 'k1'},类型：&lt;class 'set'&gt;
</code></pre>
<h2 id="重复key">重复key</h2>
<p>一个字典中的key必须是唯一的，若不是唯一的则value可能面临被覆盖的危险：</p>
<pre><code>dic = {"name": "云崖", "age": 18, "name": "Yunya"}
print(dic)

# {'name': 'Yunya', 'age': 18}
</code></pre>
<p>同理，True和1，False和0也会彼此进行覆盖：</p>
<pre><code>dic = {True: "云崖", "age": 18, 1: "Yunya"}
print(dic)

# {True: 'Yunya', 'age': 18}
</code></pre>
<p>如果你对此不了解，建议回退到布尔类型一章节中再次查看True&amp;1andFalse&amp;0之间的关系。</p>
<h1 id="操纵字典">[]操纵字典</h1>
<p>由于字典并非顺序存储（下面会简单介绍），故不支持索引操作。</p>
<p>但是字典也提供了[]操作语法，它是根据key来操作value的。</p>
<h2 id="增删改查">增删改查</h2>
<p>以下示例展示了如何使用[]对字典中的value进行操纵：</p>
<pre><code>dic = {"k1": "v1", "k2": "v2"}

# 增
dic["k3"] = "v3"
print(dic)
# {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'}

# 删，如果没有该key，则抛出keyError
del dic["k2"]
print(dic)
# {'k1': 'v1', 'k3': 'v3'}

# 改，如果没有该key，则抛出keyError
dic["k3"] = "VV3"
print(dic)
# {'k1': 'v1', 'k3': 'VV3'}

# 查，如果没有该key，则抛出keyError
result = dic["k1"]
print(result)
# v1
</code></pre>
<h2 id="多维操作">多维操作</h2>
<p>字典套列表的多维操作如下，首先需要拿到该列表：</p>
<pre><code>dic = {"k1": [1, 2, 3, 4]}

# 取出3
result = dic["k1"][2]
print(result)
# 3

# k1的列表，添加元素 "A"
dic["k1"].append("A")
print(dic)
# {'k1': [1, 2, 3, 4, 'A']}
</code></pre>
<p>字典套字典的多维操作如下，首先需要拿到被操纵的字典：</p>
<pre><code>dic = {
    "k1":{
        "k1-1":{
            "k1-2":{
                "k1-3":"HELLO,WORLD",
            }
        }
    }
}

# 拿到 k1-3 对应的value
result = dic["k1"]["k1-1"]["k1-2"]["k1-3"]
print(result)
# HELLO,WORLD
</code></pre>
<h1 id="解构语法">解构语法</h1>
<h2 id="语法">**语法</h2>
<p>**语法用于将字典中的k:v全部提取出来。</p>
<p>我们可以利用该语法的特性来对字典进行合并，将两个旧字典合并成一个新字典：</p>
<pre><code>dic_1 = {"d1k1": "A", "d1k2": "B"}
dic_2 = {"d2k1": "C", "d2k2": "D"}
result = {**dic_1, **dic_2}
print(result)
# {'d1k1': 'A', 'd1k2': 'B', 'd2k1': 'C', 'd2k2': 'D'}
</code></pre>
<h2 id="解构赋值">解构赋值</h2>
<p>字典支持平行变量赋值操作吗？当然可以！但是这样只会拿到字典的key：</p>
<pre><code>dic = {"k1": "v1", "k2": "v2"}

first, last = dic
print(first)
print(last)

# k1
# k2
</code></pre>
<p>有办法拿到value么？借助字典的values()方法即可做到，它的本质是将value全部提取出来，组成一个可迭代对象：</p>
<pre><code>dic = {"k1": "v1", "k2": "v2"}

first, last = dic.values()
print(first)
print(last)

# v1
# v2
</code></pre>
<p>你可以理解为，将value全部提取出来后转换为一个列表，类似于[“v1”, “v2”]，在Python2中的确是这样，但是到了Python3中做法改变了，目前按下不表。</p>
<p>对于一些不想要的数据项，你也可以按照列表的解构赋值操作来进行，这里不再举例。</p>
<h1 id="常用方法">常用方法</h1>
<h2 id="方法一览">方法一览</h2>
<p>常用的dict方法一览：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>get()</td>
<td>v or None</td>
<td>取字典key对应的value，如果key不存在返回None</td>
</tr>
<tr>
<td>setdefault()</td>
<td>v</td>
<td>获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v</td>
</tr>
<tr>
<td>update()</td>
<td>None</td>
<td>对原有的字典进行更新</td>
</tr>
<tr>
<td>pop()</td>
<td>v</td>
<td>删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常</td>
</tr>
<tr>
<td>keys()</td>
<td>Iterable</td>
<td>返回一个可迭代对象，该可迭代对象中只存有字典的所有key</td>
</tr>
<tr>
<td>values()</td>
<td>Iterable</td>
<td>返回一个可迭代对象，该可迭代对象中只存有字典的所有value</td>
</tr>
<tr>
<td>items()</td>
<td>Iterable</td>
<td>返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组</td>
</tr>
<tr>
<td>clear()</td>
<td>None</td>
<td>清空当前字典</td>
</tr>
</tbody>
</table>
<p>基础公用函数：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len()</td>
<td>integer</td>
<td>返回容器中的项目数</td>
</tr>
</tbody>
</table>
<h2 id="获取长度">获取长度</h2>
<p>使用len()方法来进行字典长度的获取。</p>
<p>返回int类型的值。</p>
<pre><code>dic = {"name": "云崖", "age": 18}
print(len(dic))

# 2 一组键值对被视为一个数据项，故2组键值对长度为2
</code></pre>
<p>Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。</p>
<p>PyVarObject是表示内存中长度可变的内置对象的C语言结构体。</p>
<p>直接读取这个值比调用一个方法要快很多。</p>
<h2 id="get">get()</h2>
<p>使用get()方法获取字典key对应的value，相比于[]操作更加的人性化，因为[]一旦获取不存在的key则会抛出异常，而该方法则是返回None。</p>
<pre><code>dic = {"name": "云崖", "age": 18}
username = dic.get("name")
userhobby = dic.get("hobby")

print("用户姓名:",username)
print("用户爱好:",userhobby)

# 用户姓名: 云崖
# 用户爱好: None
</code></pre>
<h2 id="setdefault">setdefault()</h2>
<p>使用setdefault()方法来获取字典key对应的value，如该字典中不存在被获取的key则会进行新增k:v，并返回v。</p>
<p>返回字典原有的value或者新设置的k:v。</p>
<pre><code>dic = {"name": "云崖", "age": 18}

# 字典有name，则取字典里的name
username = dic.setdefault("name","云崖先生")   

# 字典没有hobby，则设置hobby的value为足球与篮球并返回
userhobby = dic.setdefault("hobby","足球与篮球")  

print("用户姓名:",username)
print("用户爱好:",userhobby)

# 用户姓名: 云崖
# 用户爱好: 足球与篮球
</code></pre>
<h2 id="update">update()</h2>
<p>使用update()方法对原有的字典进行更新。</p>
<p>返回None。</p>
<pre><code>dic = {"name": "云崖", "age": 18}

dic.update(
    {"hobby": ["篮球", "足球"]}
)

print(dic)

# {'name': '云崖', 'age': 18, 'hobby': ['篮球', '足球']}
</code></pre>
<h2 id="pop">pop()</h2>
<p>使用pop()方法删除该字典中的键值对，如果不填入参数key或者key不存在则抛出异常。</p>
<p>返回被删除的value。</p>
<pre><code>dic = {"name": "云崖", "age": 18}

result = dic.pop("age")

print(result)
print(dic)

# 18
# {'name': '云崖'}
</code></pre>
<h2 id="keys">keys()</h2>
<p>返回一个可迭代对象，该可迭代对象中只存有字典的所有key。</p>
<p>Python2中返回的是列表，Python3中返回的是可迭代对象。</p>
<pre><code>dic = {"name": "云崖", "age": 18}

key_iter = dic.keys()

print(key_iter)

# dict_keys(['name', 'age'])
</code></pre>
<h2 id="values">values()</h2>
<p>返回一个可迭代对象，该可迭代对象中只存有字典的所有value。</p>
<p>Python2中返回的是列表，Python3中返回的是可迭代对象。</p>
<pre><code>dic = {"name": "云崖", "age": 18}

value_iter = dic.values()

print(value_iter)

# dict_values(['云崖', 18])
</code></pre>
<h2 id="items">items()</h2>
<p>返回一个可迭代对象，该可迭代对象中存有字典中所有的key与value，类似于列表套元组。</p>
<p>Python2中返回的是二维列表，Python3中返回的是可迭代对象。</p>
<pre><code>dic = {"name": "云崖", "age": 18}

items_iter = dic.items()

print(items_iter)

# dict_items([('name', '云崖'), ('age', 18)])
</code></pre>
<h2 id="clear">clear()</h2>
<p>清空当前字典。</p>
<p>返回None。</p>
<pre><code>dic = {"name": "云崖", "age": 18}

dic.clear()

print(dic)

# {}
</code></pre>
<h2 id="其他方法">其他方法</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>popitem()</td>
<td>(k, v)</td>
<td>随机删除一组键值对,并将删除的键值放到元组内返回</td>
</tr>
<tr>
<td>fromkeys(iter,value)</td>
<td>dict</td>
<td>第一个参数是可迭代对象，其中每一个元素都为新生成字典的key，第二个参数为同一的value值</td>
</tr>
</tbody>
</table>
<p>示例演示：</p>
<pre><code>dic1 = dict(k1="v1", k2="v2", k3="v3", k4="v4")
print(dic1.popitem())  
# ('k4', 'v4') 

dic2 = dict.fromkeys([1, 2, 3, 4], None)
print(dic2)  
# {1: None, 2: None, 3: None, 4: None}
</code></pre>
<h1 id="原理浅析">原理浅析</h1>
<h2 id="高效查找">高效查找</h2>
<p>为什么要有字典这种数据结构？</p>
<p>如果对一个无序的列表查找其中某一个value（不能进行排序），必须经过一个一个的遍历，速度会很慢。</p>
<pre><code>[3, 2, 8, 9, 11, 13]

# 如果要获取数据项11，必须经过5次查找
</code></pre>
<p>有没有一种办法，能够让速度加快？</p>
<p>为了不违背不能排序的前提，我们只能在列表存入value的时候做文章。</p>
<p>我们可以每个value都造一个独一无二的身份标识，根据这个身份标识符计算出value需要插入到列表的索引位置。</p>
<p>在取的时候同理，通过身份标识符直接就可以拿到value所在列表的索引值，无疑速度会快很多。</p>
<p>一个小总结：</p>
<ul>
<li>有一个身份标识，身份标识必须是唯一的</li>
<li>提供一个根据身份标识计算出插入位置的算法</li>
</ul>
<p>回到字典的本质，字典的key就是value的身份标识，而根据key计算出插入位置的算法被封装在了hash()函数中，这个算法也被称之为hash算法。</p>
<p>为什么key必须是唯一的，参照下面这个示例：</p>
<pre><code>["k1", "k2", "k3", "k4", "k5", "k6"]
[  3,    2,    8,    9,   11,   13]
</code></pre>
<ul>
<li>假如k5变成了k6，那么就有2个k6对应2个不同的value</li>
<li>这么做的后果就是，使用k6获取value的时候，根本不知道你需要的value是哪一个</li>
</ul>
<p>所以，干脆Python规定，key必须是不可变类型！如果有重复则新的覆盖旧的。</p>
<h2 id="hash过程">hash()过程</h2>
<p>如何通过hash()函数，确定value的插入位置？</p>
<p>实际上每个键值对在存入字典之前，都会通过hash()函数对key计算出一个hash值（也被称为散列值）：</p>
<pre><code>&gt;&gt;&gt; hash("k1")
7036545863130266253
</code></pre>
<p>而字典的底层结构是由一个2维数组嵌套组成的，也被称为散列表、hash表。</p>
<p>如下所示，每次创建字典的时候，字典都会初始化生成一个固定长度且内容全是空的2维数组，Python内部生成的散列表长度为8（可参见PyDictObject结构体源码）：</p>
<pre><code>[
	 ①  ②  ③
	[空, 空, 空], index: 0
	[空, 空, 空], index: 1
	[空, 空, 空], index: 2
	[空, 空, 空], index: 3
	[空, 空, 空], index: 4
	[空, 空, 空], index: 5
	[空, 空, 空], index: 6
	[空, 空, 空]  index: 7
]
</code></pre>
<p>①：存放根据key计算出的hash值</p>
<p>②：存放key的引用</p>
<p>③：存放value的引用</p>
<p>现在，我们要存储name:yunya的键值对，对name计算hash值：</p>
<pre><code>&gt;&gt;&gt; hash("name")
3181345887314224636
</code></pre>
<p>用计算出的hash值与散列表长度进行求余运算：</p>
<pre><code>&gt;&gt;&gt; 3181345887314224636 % 8
4
</code></pre>
<p>得到结果是4，就在散列表4的索引位置插入：</p>
<pre><code>[
	 ①  ②  ③
	[空, 空, 空], index: 0
	[空, 空, 空], index: 1
	[空, 空, 空], index: 2
	[空, 空, 空], index: 3
	[3181345887314224636, "name"的引用, "yunya"], index: 4
	[空, 空, 空], index: 5
	[空, 空, 空], index: 6
	[空, 空, 空]  index: 7
]
</code></pre>
<p>再次插入age:18，并用计算出的hash值与散列表长度进行求余运算:</p>
<pre><code>&gt;&gt;&gt; hash("age")
7064862892218627464
&gt;&gt;&gt; 7064862892218627464 % 8
0
</code></pre>
<p>得到的结果是0，就在散列表0的索引位置插入：</p>
<pre><code>[
	 ①  ②  ③
	[7064862892218627464, "age"的引用, 18], index: 0
	[空, 空, 空], index: 1
	[空, 空, 空], index: 2
	[空, 空, 空], index: 3
	[3181345887314224636, "name"的引用, "yunya"], index: 4
	[空, 空, 空], index: 5
	[空, 空, 空], index: 6
	[空, 空, 空]  index: 7
]
</code></pre>
<p>可以看见，这个2维数组不是按照顺序进行插入的，总有一些空的位置存在，该数组也被称为稀松数组。</p>
<p>由于数组是稀松的，所以dict不支持范围获取（能获取到空值），但单点存取的速度很快。</p>
<p>读取的时候也同理，但是Python的hash函数底层实现是否真的利用hash值对稀松数组长度进行简单的求余运算，这个还有待商榷。</p>
<p>因为hash算法的实现有很多种，长度求余只是最为简单的一种而已，这里用作举例，如果想具体了解其算法可以查看Python源码，<a href="https://hg.python.org/cpython/file/tip/Objects/dictobject.c" target="_blank">PyDictObject.c</a>中的perturb。</p>
<h2 id="散列冲突">散列冲突</h2>
<p>现在，我们的这个散列表中0和4的索引位置都已经存在数据了。</p>
<p>如果现在存入一个teacher:wang，那么结果会是怎么样？</p>
<pre><code>&gt;&gt;&gt; hash("teacher")
4789346189807557228
&gt;&gt;&gt; 4789346189807557228 % 8
4
</code></pre>
<p>可以发现，teacher的hash值求余算结果也是4，这个时候就会发生散列冲突。</p>
<p>最常见的做法是，向后挪！因为索引5的位置是空的，我们可以将这个键值对插入到索引5的位置：</p>
<pre><code>[
	 ①  ②  ③
	[7064862892218627464, "age"的引用, 18], index: 0
	[空, 空, 空], index: 1
	[空, 空, 空], index: 2
	[空, 空, 空], index: 3
	[3181345887314224636, "name"的引用, "yunya"], index: 4
	[4789346189807557228, "teacher"的引用, "wang"], index: 5
	[空, 空, 空], index: 6
	[空, 空, 空]  index: 7
]
</code></pre>
<p>这种查找空位的方法叫做开放定址法（openaddressing），向后查找也被称为线性探测（linearprobing）。</p>
<p>如果此时又插入一个数据项，最后key的插入索引位置也是4，则继续向后查找空位，如果查找到7还是没有空位，又从0开始找。</p>
<p>上述方法是解决散列冲突的基础方案，当然也还有更多的其他解决方案，这里再说就过头了，放在后面数构一章中再进行介绍吧。</p>
<h2 id="扩容机制">扩容机制</h2>
<p>Python的dict会对散列表的容量做出判定。</p>
<p>当容量超过三分之二时，即进行扩容（resize）机制。</p>
<p>如果散列表大小为8，在即将插入第3个键值对时进行扩容，扩容策略为已有散列表键值对个数 * 2。</p>
<p>即散列表大小扩展为12。</p>
<p>如果整个散列表已有键值对个数达到了50000，则扩容策略为已有散列表键值对个数 * 4。</p>
<p>此外，dict只会进行扩容，不会进行缩容，如果删除了1个键值对，其内存空间占用的位置并不会释放。</p>
<h2 id="不同的key优化策略">不同的key优化策略</h2>
<h3 id="整形是其本身">整形是其本身</h3>
<p>整形的hash值是其本身：</p>
<pre><code>&gt;&gt;&gt; hash(1)
1
&gt;&gt;&gt; hash(2)
2
&gt;&gt;&gt; hash(3)
3
&gt;&gt;&gt; hash(10000)
10000
</code></pre>
<h3 id="加盐策略">加盐策略</h3>
<p>在Python3.3开始，str、bytes、datetime等对象在计算散列值的时候会进行加盐处理。</p>
<p>这个盐引用内部的一个常量，该常量在每次CPython启动时会生成不同的盐值。</p>
<p>所以你会发现每次重启Python3.3以后的解释器，对相同字符串进行hash()求散列值得出的结果总是不一样的：</p>
<pre><code>$ python3
Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31)
[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; hash("k1")
8214688532022610754
&gt;&gt;&gt; exit()

$ python3
Python 3.6.8 (v3.6.8:3c6b436a57, Dec 24 2018, 02:04:31)
[GCC 4.2.1 Compatible Apple LLVM 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; hash("k1")
-7444020267993088839
&gt;&gt;&gt; exit()
</code></pre>
<p>再看Python2.7，由于没有加盐策略，所以每次重启得到的hash结果是相同的：</p>
<pre><code>$ python
Python 2.7.10 (default, Feb 22 2019, 21:55:15)
[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; hash("k1")
13696082283123634
&gt;&gt;&gt; exit()

$ python
Python 2.7.10 (default, Feb 22 2019, 21:55:15)
[GCC 4.2.1 Compatible Apple LLVM 10.0.1 (clang-1001.0.37.14)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; hash("k1")
13696082283123634
&gt;&gt;&gt; exit()
</code></pre>
<h2 id="有序字典">有序字典</h2>
<p>字典无序的观念似乎已经深入人心，但那已经都是过去式了。</p>
<p>在Python3.6之后，字典变的有序了。</p>
<p>2012年12月10日星期一的时候，<em>R. David Murray</em>向Python官方发送了一封邮件，提出建议让Python的字典变的有序。</p>
<p>这样的做法能够让Python字典的空间占用量更小，迭代速度更快，以下是邮件内容：</p>
<p><a href="https://mail.python.org/pipermail/python-dev/2012-December/123028.html" target="_blank">https://mail.python.org/pipermail/python-dev/2012-December/123028.html</a></p>
<p>我们先看看2.7中的字典：</p>
<pre><code>&gt;&gt;&gt; {chr(i) : i for i in range(10)}
{'\x01': 1, '\x00': 0, '\x03': 3, '\x02': 2, '\x05': 5, '\x04': 4, '\x07': 7, '\x06': 6, '\t': 9, '\x08': 8}
</code></pre>
<p>再来看3.6中的字典：</p>
<pre><code>&gt;&gt;&gt; {chr(i) : i for i in range(10)}
{'\x00': 0, '\x01': 1, '\x02': 2, '\x03': 3, '\x04': 4, '\x05': 5, '\x06': 6, '\x07': 7, '\x08': 8, '\t': 9}
</code></pre>
<p>果然！它确实变的有序了，关于具体细节，可以参照这封邮件，已经表述的很清楚了，下面做一个简单的示例。</p>
<p>首先，以前的散列表就是一个单纯的稀松二维数组：</p>
<pre><code>[
	[空, 空, 空], index: 0
	[空, 空, 空], index: 1
	[空, 空, 空], index: 2
	...
]
</code></pre>
<p>键值对的读取顺序来源与填加顺序。</p>
<p>索引靠前的会被先遍历拿到，索引靠后只能后被遍历出来。</p>
<p>如果这个散列表长度为8，前7个都没有数据项存入，仅有8才有，那么遍历完整个散列表需要8次：</p>
<pre><code>[
	[空, 空, 空], index: 0
	[空, 空, 空], index: 1
	[空, 空, 空], index: 2
	...
	[hash值, key的引用, value的引用], index: 7
]
</code></pre>
<p>而Python3.6之后，又新增了一个顺序数组，该数组与散列表的长度相等，初始均为8，并且会跟随散列表的扩容而进行扩容，如下示例初始状态：</p>
<pre><code>[None, None, None, ...]

[
	[空, 空, 空], index: 0
	[空, 空, 空], index: 1
	[空, 空, 空], index: 2
	...
]
</code></pre>
<p>如果说第1个键值对，被插入到散列表索引1的位置，那么在顺序数组中，则在索引0处记录下该键值对被插入在散列表中的位置(1)，如下图所示：</p>
<pre><code>[1, None, None, ...]

[
	[空, 空, 空], index: 0
	[hash值, key的引用, value的引用], index: 1
	[空, 空, 空], index: 2
	...
]
</code></pre>
<p>如果第2个键值对，被插入到散列表索引0的位置，那么在顺序数组中，则在索引1处记录下该键值对被插入在散列表中的位置(0)，如下图所示：</p>
<pre><code>[1, 0, None, ...]

[
	[hash值, key的引用, value的引用], index: 0
	[hash值, key的引用, value的引用], index: 1
	[空, 空, 空], index: 2
	...
]
</code></pre>
<p>在遍历的时候，会遍历这个顺序数组，然后通过索引值拿到散列表中对应位置的数据项，如果遍历到的值为None就结束遍历，而不用遍历完整个散列表：</p>
<pre><code>[1, 0, 7, None, None, None, None, None]

[
	[hash值, key的引用, value的引用], index: 0
	[hash值, key的引用, value的引用], index: 1
	[空, 空, 空], index: 2
	...
	[hash值, key的引用, value的引用], index: 7
]
</code></pre>
<p>类似于：</p>
<pre><code>hashTableOrderArray = [1, 0, 7, None, None, None, None, None]
hashTable = [
    ["hash", "k2", "v2"],
    ["hash", "k1", "v1"],
    [None, None, None],
    [None, None, None],
    [None, None, None],
    [None, None, None],
    [None, None, None],
    ["hash", "k3", "v3"],
]

n = 0

while n &lt; len(hashTable):
    if hashTableOrderArray[n] is not None:
        print(hashTable[hashTableOrderArray[n]])
    else:
        break
    n += 1
</code></pre>
<p>这样只需遍历3次即可，而如果不用这个顺序数组，则要完整遍历整个散列表，即8次才能拿出所有的键值对。</p>
<h1 id="字典特性">字典特性</h1>
<p>字典特性如下：</p>
<ul>
<li>字典是一个可变的容器类型</li>
<li>字典内部由散列表组成</li>
<li>字典的单点读写速度很快，但是不支持范围查找</li>
<li>字典的key必须是不可变的</li>
<li>字典在3.6之后变得有序了，这样做提升了遍历效率</li>
</ul>
<p>参考文章：<a href="https://blog.zthxxx.me/post/python-dictionary-implementation/#pydictobject-%E7%BB%93%E6%9E%84%E4%BD%93" target="_blank">PyDictObject实现</a></p>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2021-05-03 16:29</span>&nbsp;
<a href="https://www.cnblogs.com/Yunya-Cnblogs/">云崖先生</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=14727708" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(14727708);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/10.3.1/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 569467, cb_blogApp = 'Yunya-Cnblogs', cb_blogUserGuid = 'f934dd8b-6e84-4912-dbf2-08d7723e4a4c';
    var cb_entryId = 14727708, cb_entryCreatedDate = '2021-05-03 16:29', cb_postType = 1;
    updatePostStats(
        [cb_entryId],
        function(id, count) { $("#post_view_count").text(count) },
        function(id, count) { $("#post_comment_count").text(count) })
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
</script>
<a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="under-post-card">
        <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_card1"></div>
    <div id="cnblogs_c2" class="under-post-card">
        <div id='div-gpt-ad-1592366332455-0' style='width: 468px; height: 60px;'></div>
    </div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
       var commentManager = new blogCommentManager();
       commentManager.renderComments(0);
       fixPostBody();
       deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);       deliverT2();
       deliverC1C2();
       loadNewsAndKb();
       loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);       LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
       GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
       loadOptUnderPost();
       GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->
	<div id="sideBar">
		<div id="sideBarMain">
			<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>
<div id="sidebar_c3"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2021 云崖先生
<br /><span id="poweredby">Powered by .NET 5.0 on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <script>
    /**
     * @author:me@makergyt.com
     * @version:2020-07-01
     */
    window.config = {
        avatar: 'https://pic.cnblogs.com/avatar/2150956/20210220221223.png',
        github: 'makergyt',
        gallery: '1796566'
    }
</script>
<!-- 下方内容请勿擅自修改，除非知道明确含义，如进行完善和扩展，请fork源码(https://github.com/MakerGYT/cnblogs-theme-next)后提交pull request;-->
<!-- 引入在线字体-->
<!--<link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Noto Serif SC:wght@400;500;700&display=swap&subset=latin,latin-ext">-->
<!-- 引入图标库-->
<link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<!-- 顶部滚动条-->
<script src="https://cdn.jsdelivr.net/gh/djyde/ToProgress/ToProgress.min.js"></script>
<script type="text/javascript">
    let progressBar = new ToProgress({
        color: getComputedStyle(document.documentElement).getPropertyValue('--primary-color')
    })
    progressBar.reset()
    // 如未做大幅修改，请保留下方内容
    $('#poweredby').append('&nbsp;&&nbsp;<a href="https://github.com/makergyt/cnblogs-theme-next">cnblogs-theme-next</a>')
    // 获取默认基础信息
    window.isPost = $('.forFlow').find('#post_detail').length ? true : false;
    window.blogSlug = currentBlogApp;
    var footerOverTestArray = $($("#footer")[0].childNodes[2]).text().trim().split(" ");

    config = Object.assign({
        siteTitle: $('#Header1_HeaderTitle').text(),
        author: footerOverTestArray[footerOverTestArray.length - 1],
        avatar: $('.author_avatar').attr('src'),
        github: blogSlug,
        gallery: null
    }, config);

    var linkObject = document.createElement("link");
    linkObject.rel = "shortcut icon";
    linkObject.href = config.avatar;

    // 设置摘要
    function setDesc() {
        $('#cnblogs_post_description').css('display', 'block')
        $('#cnblogs_post_description').prepend('<h3 id="post-description-meta">摘 要</h3>')
        // 由于标签是网络请求，可能在修改dom后返回，故重新请求后再修改
        $.ajax({
            url: getAjaxBaseUrl() + "CategoriesTags.aspx",
            type: "get",
            contentType: "application/json; charset=utf-8",
            data: {
                blogId: cb_blogId,
                postId: cb_entryId,
            },
            cache: !1,
            dataType: "text",
            timeout: 1e4,
            success: function (n) {
                n && $("#cnblogs_post_description").append(n.replace('EntryTag', 'post-keyword').replace('标签', '关键词'))
                $('#EntryTag').remove()
            }
        })
    }
    // 设置参考文献标题
    function setFoot() {
        $('.footnotes').prepend('<h1 id="-参考文献" class="footnotes-meta">参 考 文 献</h1>')
    }
    // 设置左侧目录
    function setContent() {
        if ($('#post-toc-wrap').length) return;
        var toc = $('<div id="post-toc-wrap"><h2 style="text-align:center">阅读目录</h2></div>')
        $('#blog-news').prepend(toc)
        var captions_ori = $("#cnblogs_post_body h1"),
            captions_ori2 = $("#cnblogs_post_body h2"),
            captions = $("#cnblogs_post_body h1,#cnblogs_post_body h2").clone(),
            content = $("<ol id='post-toc'></ol>");

        toc.append(content.append(captions));
        toc.append('<div class="back-to-top" onclick="toScroll(0,500)"><i class="fa fa-arrow-up"></i>&nbsp;<span id="btc-persent">0%</span></div>')

        var index = -1, index2 = -1;
        captions.replaceWith(function () {
            var self = this;
            if (self.tagName == "H1" || self.tagName == "h1") {
                // 设置点击目录跳转
                index += 1;
                $('<a name="' + '_caption_' + index + '"></a>').insertBefore(captions_ori[index]);
                return '<li id="' + index + 'li"><a href="#_caption_' + index + '">' + self.innerHTML + '</a><ol></ol></li>';
            } else {
                index2 += 1;
                $('<a name="' + '_caption' + index2 + '"></a>').insertBefore(captions_ori2[index2]);
                $("#" + index + "li ol").append("<li><a href='#_caption" + index2 + "' style='color:#5f5f5f;'>" + self.innerHTML + "</a></li>");
                return;
            }
        });
    }
    // 滚动至顶部
    function toScroll(endScroll, time) {
        $('html,body').stop().animate({ scrollTop: endScroll }, time);
    }
    function onScroll() {
        // 上拉至指定位置贴顶
        var oldScrollNum = 0;

        window.onscroll = function () {
            var t = document.documentElement.scrollTop || document.body.scrollTop;
            if (t > oldScrollNum) {
                if (t > 135) {
                    $('.site-author').remove()
                    $('#sidebar_categories').hide()
                    setContent()
                }
                if (t > 270) {
                    $("#post-toc-wrap").addClass("affix");
                }
            } else {
                if (t <= 135) {
                    $('#post-toc-wrap').remove()
                    $('#sidebar_categories').show()
                    setAuthor()
                }
                if (t <= 270) {
                    $("#post-toc-wrap").removeClass("affix");
                }
            }
            oldScrollNum = t;
            // 滚动条
            var docHeight = $(document).height(),
                windowHeight = $(window).height(),
                scrollPercent = (t / (docHeight - windowHeight)) * 100;
            progressBar.setProgress(scrollPercent);
            $('#btc-persent').replaceWith('<span id="btc-persent">' + scrollPercent.toFixed() + '%</span>')
        }
    }
    function setAuthor() {
        if ($('.site-author').length) return;
        var siteAuthor = $('<div class="site-author motion-element"><img class="site-author-image" src="' + config.avatar + '"><p class="site-author-name">' + config.author + '</p></div>');
        siteAuthor.append('<div class="site-state">' + $('.blogStats').html() + '</div>')
        var links = $('<div class="links-of-author"></div>')
        links.append('<div class="links-of-author-item"><a href="https://msg.cnblogs.com/send/' + config.author + '"><i class="fa fa-fw fa-envelope"></i></a></div>'
            + '<div class="links-of-author-item"><a id="blog_nav_rss" href="https://www.cnblogs.com/' + blogSlug + '/rss/" data-rss="https://www.cnblogs.com/' + blogSlug + '/rss/" style="display: inline !important;"><i class="fa fa-fw fa-rss"></i></a></div>')
        $('#blog-news').prepend(siteAuthor.append(links))
    }
    // 设置导航区
    function setNav() {
        var url = window.location.href;
        $('.brand').attr('href', '/' + blogSlug)
        $('.site-title').text(config.siteTitle)
        $('.menu-item-home a:first').attr('href', '/' + blogSlug)
        $('.menu-item-archives a:first').attr('href', '/' + blogSlug + '/p')
        if (config.gallery) {
            $('.menu-item-gallery a:first').attr('href', '/' + blogSlug + '/gallery/' + config.gallery + '.html')
            $('.menu-item-gallery').css('display', 'block')

            if (/gallery/.test(url)) {
                $('.menu-item-home').removeClass('menu-item-active')
                $('.menu-item-gallery').addClass('menu-item-active')
            }
        }

        if (/(\/p)$/.test(url)) {
            $('.menu-item-home').removeClass('menu-item-active')
            $('.menu-item-archives').addClass('menu-item-active')
        }
    }

    // 设置右上角github跳转链接
    function setGithub() {
        $('.github-corner').attr('href', 'https://github.com/' + config.github)
    }
    // 在响应式设计中，菜单折叠打开事件
    function setToggle() {
        document.querySelector('.site-nav-toggle .toggle').addEventListener('click', () => {
            event.currentTarget.classList.toggle('toggle-close');
            var e = document.querySelector('.site-nav'),
                t = e.classList.contains('site-nav-on') ? 'slideUp' : 'slideDown';
            'function' == typeof Velocity ? Velocity(e, t, {
                duration: 200,
                complete: function () {
                    e.classList.toggle('site-nav-on')
                }
            }) : e.classList.toggle('site-nav-on')
        });
    }
    function setCommentStyle() {
        let t = $(".feedbackItem");
        if (t.length > 0) {
            $.each(t, function (t) {
                let e = $(this)
                    , n = e.find(".feedbackCon")
                    , o = e.find(".feedbackListSubtitle")
                    , i = n.length ? n.find(".blog_comment_body") : []
                    , s = ""
                    , a = i.length ? i.attr("id").split("_") : void 0;
                if (a && a.length > 0) {
                    let t = a[a.length - 1]
                        , n = t.toString().match(/[0-9]/g);
                    $.isArray(n) && (t = n.join(""));
                    let o = $("#comment_" + t + "_avatar")
                        , i = o.length > 0 ? $.trim(o.text()) : "https://cdn.jsdelivr.net/gh/BNDong/Cnblogs-Theme-SimpleMemory@master/img/webp/default_avatar.webp"
                        , l = $("#a_comment_author_" + t)
                        , c = l.length ? l.attr("href") : "javascropt:void(0);";
                    s = '<div class="feedbackAvatar"><a href="' + c + '" target="_blank"><img src="' + i + '"/></a></div>',
                        e.prepend(s)
                }
                o.length && o.find(".louzhu").length && o.addClass("feedbackListSubtitle-louzhu")
            })
        }
    }
    function setPreNext() {
        var pnp = $("#post_next_prev a");
        if (!pnp.length) return;
        var cont = $('#post_next_prev').text();
        var wrapper = $('<div class="post_next_prev"><div class="pre-block"></div><div class="next-block"></div></div>')
        $("#post_next_prev").replaceWith(wrapper)
        var pre = $('<a href="' + pnp[1].href + '"><div class="post_next_prev_label">&#9668上一篇</div><div>' + pnp[1].innerText + '</div></a>')

        if (pnp.length > 2) {
            $('.pre-block').append(pre)
            var next = $('<a href="' + pnp[3].href + '"><div class="post_next_prev_label">下一篇&#9658</div><div>' + pnp[3].innerText + '</div></a>')
            $('.next-block').append(next)
        } else {
            if (/上一篇/.test(cont)) {
                $('.pre-block').append(pre)
            } else if (/下一篇/.test(cont)) {
                var next = $('<a href="' + pnp[1].href + '"><div class="post_next_prev_label">下一篇&#9658</div><div>' + pnp[1].innerText + '</div></a>')
                $('.next-block').append(next)
            }
        }
    }
    setGithub();
    setToggle();
    setNav();
    setTimeout(() => {
        setAuthor();
    }, 500);
    // 只对文章页
    if (isPost) {
        setFoot();
        // 由于加载需要时间故增加延时后操作
        setTimeout(() => {
            setDesc();
            setPreNext();
            onScroll();
        }, 500);
        setTimeout(() => {
            setCommentStyle()
        }, 1000)
    }
</script>

<!-- 取消排版宽字符 -->
<script>
    let p = document.querySelectorAll("p");
    p.forEach(function (ele, index) {
        ele.innerHTML = ele.innerHTML.replace(/\u200B/g, '').trim();
    })
</script>

<!-- 引入代码复制 -->
<script src="https://cdn.bootcss.com/clipboard.js/2.0.4/clipboard.min.js"></script>
<script src="https://blog-static.cnblogs.com/files/YunyaSir/title_copy.js"></script>

<!-- 更改高亮样式，用默认的即可-->
<!-- "https://cdn.jsdelivr.net/npm/highlight.js@10.1.1/styles/github.min.css"-->
<!-- 白 -->
<!-- <link href="https://blog-static.cnblogs.com/files/YunyaSir/github_gist.css" rel="stylesheet"> -->
<link href="https://blog-static.cnblogs.com/files/YunyaSir/github.css" rel="stylesheet">

<!-- 黑 -->
<!-- <link href="https://blog-static.cnblogs.com/files/YunyaSir/qtcreator_dark.css" rel="stylesheet"> -->
<!-- <link href="https://blog-static.cnblogs.com/files/YunyaSir/monokai_sublime.css" rel="stylesheet">-->

    </div>

    <input type="hidden" id="antiforgery_token" value="CfDJ8L-rpLgFVEJMgssCVvNUAjvkXOYy8UlKDAXWDmR8Vr811DHAY8wp1t-N8C7mVZqsUmabH-ioc43HbtgkXweZBEpJViguO0MoMkJA19r8d3RIFbxlvknRazZi00EKWiUtyNudwevl0DE2_iDzw3rf1wk" />
</body>
</html>
